{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to flare Web-App development framework for Python About flare is an app development framework for Python-based web-apps running on top of Pyodide in the browser. It has integrations to concepts with ViUR , an MVC-framework for the Google App Engine platform, but can also be used stand-alone. Fire up the tiny Hello World live demo.","title":"Home"},{"location":"#welcome-to-flare","text":"Web-App development framework for Python","title":"Welcome to flare"},{"location":"#about","text":"flare is an app development framework for Python-based web-apps running on top of Pyodide in the browser. It has integrations to concepts with ViUR , an MVC-framework for the Google App Engine platform, but can also be used stand-alone. Fire up the tiny Hello World live demo.","title":"About"},{"location":"config/","text":"Configuration config.py Coming soon. Serving own Pyodide The script bin/get-pyodide.py downloads a minimal Pyodide with only micropip and setuptools from the Pyodide CDN. Pyodide can also be entirely built and configured on your own, for this check the documentation . Depending on the location where you want to serve your app, some more configuration might be necessary regarding the WASM mimetype. Google App Engine To serve your own Pyodide via Google App Engine, add the following lines to your app.yaml file and modify them when needed, as Google App Engine doesn't recognize WASM files correctly. handlers: - url: /pyodide/(.*\\.wasm)$ static_files: pyodide/\\1 upload: pyodide/.*\\.wasm$ mime_type: application/wasm - url: /pyodide static_dir: pyodide Apache Webserver For apache web-server, this .htaccess configuration helped to serve the app correctly. RewriteEngine off Options -ExecCGI +Indexes IndexOrderDefault Descending Date #Header always set Access-Control-Allow-Origin \"*\" #Header always set Access-Control-Allow-Methods GET <FilesMatch \"\\.py$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .py AddType text/plain .py </FilesMatch> <FilesMatch \"\\.data$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .data AddType application/octet-stream .data </FilesMatch> <FilesMatch \"\\.wasm$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .wasm AddType application/wasm .wasm </FilesMatch>","title":"Configuration"},{"location":"config/#configuration","text":"","title":"Configuration"},{"location":"config/#configpy","text":"Coming soon.","title":"config.py"},{"location":"config/#serving-own-pyodide","text":"The script bin/get-pyodide.py downloads a minimal Pyodide with only micropip and setuptools from the Pyodide CDN. Pyodide can also be entirely built and configured on your own, for this check the documentation . Depending on the location where you want to serve your app, some more configuration might be necessary regarding the WASM mimetype.","title":"Serving own Pyodide"},{"location":"config/#google-app-engine","text":"To serve your own Pyodide via Google App Engine, add the following lines to your app.yaml file and modify them when needed, as Google App Engine doesn't recognize WASM files correctly. handlers: - url: /pyodide/(.*\\.wasm)$ static_files: pyodide/\\1 upload: pyodide/.*\\.wasm$ mime_type: application/wasm - url: /pyodide static_dir: pyodide","title":"Google App Engine"},{"location":"config/#apache-webserver","text":"For apache web-server, this .htaccess configuration helped to serve the app correctly. RewriteEngine off Options -ExecCGI +Indexes IndexOrderDefault Descending Date #Header always set Access-Control-Allow-Origin \"*\" #Header always set Access-Control-Allow-Methods GET <FilesMatch \"\\.py$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .py AddType text/plain .py </FilesMatch> <FilesMatch \"\\.data$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .data AddType application/octet-stream .data </FilesMatch> <FilesMatch \"\\.wasm$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .wasm AddType application/wasm .wasm </FilesMatch>","title":"Apache Webserver"},{"location":"html5/","text":"html5 flare is entirely established on top of a library called html5 . This library manages access to the browser's DOM and its items, by implementing a Python object wrapper class for every HTML5-element. This is called a widget . For example html5.Div() is the widget representing a div-element, or html5.A() a widget representing an a-element. The document's body and head can directly be accessed by the static widgets html5.Head() and html5.Body() . All these widgets are inheriting from an abstract widget wrapper class called html5.Widget . html5.Widget is the overall superclass which contains most of the functions used when working with DOM elements. Therefore, all widgets are usually handled the same way. First steps When working with native HTML5 widgets, every widget must be created separately and stacked together in the desired order. This practise is well known from JavaScript's createElement-function. Here's a little code sample. from flare import * # Creating a new a-widget a = html5.A() a[\"href\"] = \"https://www.viur.dev\" # assign value to href-attribute a[\"target\"] = \"_blank\" # assign value to target-attribute a.addClass(\"link\") # Add style class \"link\" to element # Append text node \"Hello World\" to the a-element a.appendChild(html5.TextNode(\"Hello World\")) # Append the a-widget to the body-widget html5.Body().appendChild(a) Summarized: html5.Xyz() creates an instance of the desired widget (the notation is that the first letter is always uppercase, rest is hold lowercase, therefore html5.Textarea() for a textarea is used) Attributes are accessable via attribute indexing, like widget[\"attribute\"] . There are some special attributes like style or data that are providing a dict-like access, so widget[\"style\"][\"border\"] = \"1px solid red\" is used. Stacking is performed with widget.appendChild() . There's also widget.prependChild() , widget.insertBefore() and widget.removeChild() for further insertion or removal operations. Parsing widgets from HTML-code Above result can also be achieved much faster, when the build-in HTML5 parser is used. from flare import * html5.Body().appendChild( \"<a href='https://www.viur.dev' target='_blank' class='viur'>Hello World</a>\" ) Much simpler, right? This is a very handy feature for prototyping and to quickly integrate new HTML layouts. Widget.appendChild() and other, corresponding functions, allow for an arbitrary number of elements to be added. HTML-code, more widgets, text or even lists or tuples can be given to these functions, like so ul = html5.Ul() ul.appendChild(\"<li>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"and same as I\")) Inheritance is normal In most cases, both methods shown above are used together where necessary and useful. Especially when creating new Widgets with a custom behavior inside your app, knowledge of both worlds is required. To create new components, inheriting from existing widgets is usual. If we would like to add our link multiple times within our app, with additional click tracking, we can make it a separate widget, like so: import logging from flare import * class Link(html5.A): def __init__(self, url, *args, target=\"_blank\", **kwargs): super().__init__() self.addClass(\"link\") self[\"href\"] = url self[\"target\"] = \"_blank\" self.appendChild(*args, **kwargs) self.sinkEvent(\"onClick\") def onClick(self, event): logging.info(f\"The link to {self['href']} has been clicked\") html5.Body().appendChild( # Create a link with text Link(\"https://www.viur.dev\", \"ViUR Framework\"), \"<br>\", # Create link with logo Link(\"https://www.python.org\", \"\"\" <img src=\"https://www.python.org/static/community_logos/python-powered-h-50x65.png\" title=\"Python Programming Language\"> \"\"\") ) In this example, we just made our first custom component: The Link -class can be arbitrarily used. Widget fundamentals Following sections describe the most widely used functions of the html5.Widget -class which are inherited by any widget or huger component in flare. Constructor All Widgets in html5 share the same __init__ -function, having the following signature: def Widget.__init__(self, *args, appendTo=None, style=None, **kwargs) *args are any positional arguments that are passed to self.appendChild() . These can be either other widgets or strings containing HTML-code. Non-container widgets like html5.Br() or html5.Hr() don't allow anything passed to this parameter, and throw an Exception. appendTo can be set to another html5.Widget where the constructed widget automatically will be appended to. It substitutes an additional appendChild() -call to insert the constructed Widget to the parent. style allows to specify CSS-classes which are added to the constructed widget using **kwargs specifies any other parameters that are passed to appendChild() , like variables. appendChild(), prependChild(), insertBefore(), fromHTML(), removeChild() These methods manipulate the DOM and it's html elements appendChild() Appends a new child to the parent element: self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") If replace=True is passed as an argument next to the html code, this method will discard all children of the parent element and replace them. prependChild() Prepends a new child to the parent element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint2 = self.nav.appendChild(\"\"\"<li>Navigation Point 2</li>\"\"\") navpoint2.prependChild((\"\"\"<li>Navigation Point 1</li>\"\"\")) If replace=True is passed as an argument next to the html code, this method will discard all children of the parent element and replace them. insertBefore() Inserts a new child element before the target child element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint = self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") navpoint3 = self.nav.appendChild((\"\"\"<li>Navigation Point 3</li>\"\"\")) navpoint2 = self.nav.insertBefore((\"\"\"<li>Navigation Point 2</li>\"\"\"), navpoint3) If the child element that the new element is supposed to be inserted before does not exist, the new element is appended to the parent instead. fromHTML() Instantiates a widget from an html string that we can access in our python code. removeChild() Removes the child from the parent element removeAllChildren() Removes all child elements from the parent element addClass(), removeClass(), toggleClass(), hasClass() These methods are helpful for adding classes dynamically. addClass() Adds a class to the html5 element and checks to prevent adding the same class. nav = self.appendChild(\"\"\"<ul></ul>\"\"\") nav.addClass('navlist') removeClass() Checks if the object has that class and removes it nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") nav.removeClass('big-red-warning-border-color') toggleClass() Toggles a class on and off, depending on wether it has already been added or not. If the element already has the class, it is removed. If the element does not have the class already, it is added to it. hasClass() Checks if the element has a given class or not. Returns True if class name is found and False otherwise. nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") if nav.hasClass('big-red-warning-border-color'): print(\"Help! There is a big red border around this element! Remove the class so we can feel safe again\") enable(), disable() These methods will enable or disable an element in the DOM. Useful for forms and similar UI applications. hide(), show() Will hide or show and element on demand. This is done by adding the hidden attribute to the element or removing it accordingly. Event handling todo HTML parser reference todo Widget configuration todo html5.parseHTML() todo html5.fromHTML() todo @html5.tag todo","title":"html5"},{"location":"html5/#html5","text":"flare is entirely established on top of a library called html5 . This library manages access to the browser's DOM and its items, by implementing a Python object wrapper class for every HTML5-element. This is called a widget . For example html5.Div() is the widget representing a div-element, or html5.A() a widget representing an a-element. The document's body and head can directly be accessed by the static widgets html5.Head() and html5.Body() . All these widgets are inheriting from an abstract widget wrapper class called html5.Widget . html5.Widget is the overall superclass which contains most of the functions used when working with DOM elements. Therefore, all widgets are usually handled the same way.","title":"html5"},{"location":"html5/#first-steps","text":"When working with native HTML5 widgets, every widget must be created separately and stacked together in the desired order. This practise is well known from JavaScript's createElement-function. Here's a little code sample. from flare import * # Creating a new a-widget a = html5.A() a[\"href\"] = \"https://www.viur.dev\" # assign value to href-attribute a[\"target\"] = \"_blank\" # assign value to target-attribute a.addClass(\"link\") # Add style class \"link\" to element # Append text node \"Hello World\" to the a-element a.appendChild(html5.TextNode(\"Hello World\")) # Append the a-widget to the body-widget html5.Body().appendChild(a) Summarized: html5.Xyz() creates an instance of the desired widget (the notation is that the first letter is always uppercase, rest is hold lowercase, therefore html5.Textarea() for a textarea is used) Attributes are accessable via attribute indexing, like widget[\"attribute\"] . There are some special attributes like style or data that are providing a dict-like access, so widget[\"style\"][\"border\"] = \"1px solid red\" is used. Stacking is performed with widget.appendChild() . There's also widget.prependChild() , widget.insertBefore() and widget.removeChild() for further insertion or removal operations.","title":"First steps"},{"location":"html5/#parsing-widgets-from-html-code","text":"Above result can also be achieved much faster, when the build-in HTML5 parser is used. from flare import * html5.Body().appendChild( \"<a href='https://www.viur.dev' target='_blank' class='viur'>Hello World</a>\" ) Much simpler, right? This is a very handy feature for prototyping and to quickly integrate new HTML layouts. Widget.appendChild() and other, corresponding functions, allow for an arbitrary number of elements to be added. HTML-code, more widgets, text or even lists or tuples can be given to these functions, like so ul = html5.Ul() ul.appendChild(\"<li>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"and same as I\"))","title":"Parsing widgets from HTML-code"},{"location":"html5/#inheritance-is-normal","text":"In most cases, both methods shown above are used together where necessary and useful. Especially when creating new Widgets with a custom behavior inside your app, knowledge of both worlds is required. To create new components, inheriting from existing widgets is usual. If we would like to add our link multiple times within our app, with additional click tracking, we can make it a separate widget, like so: import logging from flare import * class Link(html5.A): def __init__(self, url, *args, target=\"_blank\", **kwargs): super().__init__() self.addClass(\"link\") self[\"href\"] = url self[\"target\"] = \"_blank\" self.appendChild(*args, **kwargs) self.sinkEvent(\"onClick\") def onClick(self, event): logging.info(f\"The link to {self['href']} has been clicked\") html5.Body().appendChild( # Create a link with text Link(\"https://www.viur.dev\", \"ViUR Framework\"), \"<br>\", # Create link with logo Link(\"https://www.python.org\", \"\"\" <img src=\"https://www.python.org/static/community_logos/python-powered-h-50x65.png\" title=\"Python Programming Language\"> \"\"\") ) In this example, we just made our first custom component: The Link -class can be arbitrarily used.","title":"Inheritance is normal"},{"location":"html5/#widget-fundamentals","text":"Following sections describe the most widely used functions of the html5.Widget -class which are inherited by any widget or huger component in flare.","title":"Widget fundamentals"},{"location":"html5/#constructor","text":"All Widgets in html5 share the same __init__ -function, having the following signature: def Widget.__init__(self, *args, appendTo=None, style=None, **kwargs) *args are any positional arguments that are passed to self.appendChild() . These can be either other widgets or strings containing HTML-code. Non-container widgets like html5.Br() or html5.Hr() don't allow anything passed to this parameter, and throw an Exception. appendTo can be set to another html5.Widget where the constructed widget automatically will be appended to. It substitutes an additional appendChild() -call to insert the constructed Widget to the parent. style allows to specify CSS-classes which are added to the constructed widget using **kwargs specifies any other parameters that are passed to appendChild() , like variables.","title":"Constructor"},{"location":"html5/#appendchild-prependchild-insertbefore-fromhtml-removechild","text":"These methods manipulate the DOM and it's html elements","title":"appendChild(), prependChild(), insertBefore(), fromHTML(), removeChild()"},{"location":"html5/#appendchild","text":"Appends a new child to the parent element: self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") If replace=True is passed as an argument next to the html code, this method will discard all children of the parent element and replace them.","title":"appendChild()"},{"location":"html5/#prependchild","text":"Prepends a new child to the parent element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint2 = self.nav.appendChild(\"\"\"<li>Navigation Point 2</li>\"\"\") navpoint2.prependChild((\"\"\"<li>Navigation Point 1</li>\"\"\")) If replace=True is passed as an argument next to the html code, this method will discard all children of the parent element and replace them.","title":"prependChild()"},{"location":"html5/#insertbefore","text":"Inserts a new child element before the target child element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint = self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") navpoint3 = self.nav.appendChild((\"\"\"<li>Navigation Point 3</li>\"\"\")) navpoint2 = self.nav.insertBefore((\"\"\"<li>Navigation Point 2</li>\"\"\"), navpoint3) If the child element that the new element is supposed to be inserted before does not exist, the new element is appended to the parent instead.","title":"insertBefore()"},{"location":"html5/#fromhtml","text":"Instantiates a widget from an html string that we can access in our python code.","title":"fromHTML()"},{"location":"html5/#removechild","text":"Removes the child from the parent element","title":"removeChild()"},{"location":"html5/#removeallchildren","text":"Removes all child elements from the parent element","title":"removeAllChildren()"},{"location":"html5/#addclass-removeclass-toggleclass-hasclass","text":"These methods are helpful for adding classes dynamically.","title":"addClass(), removeClass(), toggleClass(), hasClass()"},{"location":"html5/#addclass","text":"Adds a class to the html5 element and checks to prevent adding the same class. nav = self.appendChild(\"\"\"<ul></ul>\"\"\") nav.addClass('navlist')","title":"addClass()"},{"location":"html5/#removeclass","text":"Checks if the object has that class and removes it nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") nav.removeClass('big-red-warning-border-color')","title":"removeClass()"},{"location":"html5/#toggleclass","text":"Toggles a class on and off, depending on wether it has already been added or not. If the element already has the class, it is removed. If the element does not have the class already, it is added to it.","title":"toggleClass()"},{"location":"html5/#hasclass","text":"Checks if the element has a given class or not. Returns True if class name is found and False otherwise. nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") if nav.hasClass('big-red-warning-border-color'): print(\"Help! There is a big red border around this element! Remove the class so we can feel safe again\")","title":"hasClass()"},{"location":"html5/#enable-disable","text":"These methods will enable or disable an element in the DOM. Useful for forms and similar UI applications.","title":"enable(), disable()"},{"location":"html5/#hide-show","text":"Will hide or show and element on demand. This is done by adding the hidden attribute to the element or removing it accordingly.","title":"hide(), show()"},{"location":"html5/#event-handling","text":"todo","title":"Event handling"},{"location":"html5/#html-parser-reference","text":"todo","title":"HTML parser reference"},{"location":"html5/#widget-configuration","text":"todo","title":"Widget configuration"},{"location":"html5/#html5parsehtml","text":"todo","title":"html5.parseHTML()"},{"location":"html5/#html5fromhtml","text":"todo","title":"html5.fromHTML()"},{"location":"html5/#html5tag","text":"todo","title":"@html5.tag"},{"location":"setup/","text":"Setup Setting up a new Python web-app with flare is fairly easy. This section describes several things and ways how flare can be used and configured. HTML skeleton Below is a shortened version of the code from hello.html delivered together with the flare repo. Such a skeleton must be individually created for an app written with flare . <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <link rel=\"stylesheet\" href=\"assets/css/style.min.css\"/> <!-- (1) --> <script src=\"https://pyodide-cdn2.iodide.io/v0.15.0/full/pyodide.js\"></script> <!-- <script src=\"pyodide/pyodide.js\"></script> --> <!-- (2) --> <script src=\"assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ prelude: // (3) ` print(\"I'm before any fetch\") ` fetch: { // (4) \"flare\": { \"path\": \"flare\" } }, kickoff: // (5) ` from flare import * html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') flare.popup.Alert(\"Hello World\") ` }); } ); </script> </head> <body class=\"is-loading\"> <!-- (6) --> </body> </html> Notable are the following sections: This is the include for the used Pyodide version. When quickly setting up a project, the default CDN version of Pyodide can be used and is loaded from here. Indeed, it is also possible to serve Pyodide on your own. For this, the utility script bin/get-pyodide.py can be used. This script downloads a minimal version of Pyodide delivered from the CDN and stores it into a folder named pyodide/ . In such a case, the CDN-include here must be removed, and replaced by the local include. get-pyodide.py patches some Pyodide-files to directly run from the URL /pyodide . You can override this setting by specifying a variable window.languagePluginLoader before including the pyodide.js . flare serves a piece of JavaScript code that is necessary to pre-load flare itself and the Python application. For development, it was useful to directly fetch the py-files from the server and store them into a browser-internal filesystem when the Python interpreter from Pyodide can find it. This is done using the module in init.js and the configuration described next. prelude is some Python code that is executed before any modules are fetched. It can be omitted, if not wanted. fetch describes Python source modules that are being fetched before the application starts. This is very useful for development purposes. For every entry (which is the name of the Python package to be created), a further object describing the fetch path and an optional optional attribute is provided. Using the path -attribute, the flare init script looks for a file files.json which provides a listing of the files being fetched. This file is generated using bin/gen-files-json.py which is described below. A Pyodide package can also be pre-compiled from source files, but this is not described in detail here, yet. kickoff is the Python code that is executed when all fetching is done and nothing failed. It is used as the entry point to start the web-app. In the hello.html file, it is just some \"Hello World\" stuff dumped out using flare. The class is-loading is automatically removed when the kickoff code successfully executed. It can be used to show a loading animation or something similar. Writing huger apps When writing huger apps with multiple Python files, the above example doesn't satisfy. For this case, an HTML-file like above still serves as the entry point for the app, but requires a little more configuration. Let's thing about the following minimal setup for a huger app: /flare is the flare repo serving as a library _ /myapp contains our app, which exists only of the files index.html the app entry HTML __init__.py the app source code files.json which is the index file for the flare init script to find its sources We only describe the files in /myapp : index.html <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <script src=\"https://pyodide-cdn2.iodide.io/v0.15.0/full/pyodide.js\"></script> <script src=\"/flare/assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ fetch: { \"flare\": { \"path\": \"/flare/flare\" }, \"myapp\": { \"path\": \".\" } } } ); } ); </script> </head> <body class=\"is-loading\"> </body> </html> init .py : from flare import * if __name__ == \"myapp\": html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') popup.Alert(\"Hello World\") files.json : [ \"__init__.py\" ] The files.json was simply generated using the by ../flare/bin/gen-files-json.py . Whenever a Python file is added, this must be done once. The files.json should also be added to version control, to make the app run out-of-the-box.","title":"Setup"},{"location":"setup/#setup","text":"Setting up a new Python web-app with flare is fairly easy. This section describes several things and ways how flare can be used and configured.","title":"Setup"},{"location":"setup/#html-skeleton","text":"Below is a shortened version of the code from hello.html delivered together with the flare repo. Such a skeleton must be individually created for an app written with flare . <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <link rel=\"stylesheet\" href=\"assets/css/style.min.css\"/> <!-- (1) --> <script src=\"https://pyodide-cdn2.iodide.io/v0.15.0/full/pyodide.js\"></script> <!-- <script src=\"pyodide/pyodide.js\"></script> --> <!-- (2) --> <script src=\"assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ prelude: // (3) ` print(\"I'm before any fetch\") ` fetch: { // (4) \"flare\": { \"path\": \"flare\" } }, kickoff: // (5) ` from flare import * html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') flare.popup.Alert(\"Hello World\") ` }); } ); </script> </head> <body class=\"is-loading\"> <!-- (6) --> </body> </html> Notable are the following sections: This is the include for the used Pyodide version. When quickly setting up a project, the default CDN version of Pyodide can be used and is loaded from here. Indeed, it is also possible to serve Pyodide on your own. For this, the utility script bin/get-pyodide.py can be used. This script downloads a minimal version of Pyodide delivered from the CDN and stores it into a folder named pyodide/ . In such a case, the CDN-include here must be removed, and replaced by the local include. get-pyodide.py patches some Pyodide-files to directly run from the URL /pyodide . You can override this setting by specifying a variable window.languagePluginLoader before including the pyodide.js . flare serves a piece of JavaScript code that is necessary to pre-load flare itself and the Python application. For development, it was useful to directly fetch the py-files from the server and store them into a browser-internal filesystem when the Python interpreter from Pyodide can find it. This is done using the module in init.js and the configuration described next. prelude is some Python code that is executed before any modules are fetched. It can be omitted, if not wanted. fetch describes Python source modules that are being fetched before the application starts. This is very useful for development purposes. For every entry (which is the name of the Python package to be created), a further object describing the fetch path and an optional optional attribute is provided. Using the path -attribute, the flare init script looks for a file files.json which provides a listing of the files being fetched. This file is generated using bin/gen-files-json.py which is described below. A Pyodide package can also be pre-compiled from source files, but this is not described in detail here, yet. kickoff is the Python code that is executed when all fetching is done and nothing failed. It is used as the entry point to start the web-app. In the hello.html file, it is just some \"Hello World\" stuff dumped out using flare. The class is-loading is automatically removed when the kickoff code successfully executed. It can be used to show a loading animation or something similar.","title":"HTML skeleton"},{"location":"setup/#writing-huger-apps","text":"When writing huger apps with multiple Python files, the above example doesn't satisfy. For this case, an HTML-file like above still serves as the entry point for the app, but requires a little more configuration. Let's thing about the following minimal setup for a huger app: /flare is the flare repo serving as a library _ /myapp contains our app, which exists only of the files index.html the app entry HTML __init__.py the app source code files.json which is the index file for the flare init script to find its sources We only describe the files in /myapp : index.html <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <script src=\"https://pyodide-cdn2.iodide.io/v0.15.0/full/pyodide.js\"></script> <script src=\"/flare/assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ fetch: { \"flare\": { \"path\": \"/flare/flare\" }, \"myapp\": { \"path\": \".\" } } } ); } ); </script> </head> <body class=\"is-loading\"> </body> </html> init .py : from flare import * if __name__ == \"myapp\": html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') popup.Alert(\"Hello World\") files.json : [ \"__init__.py\" ] The files.json was simply generated using the by ../flare/bin/gen-files-json.py . Whenever a Python file is added, this must be done once. The files.json should also be added to version control, to make the app run out-of-the-box.","title":"Writing huger apps"}]}