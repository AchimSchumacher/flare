{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to flare Web-App development framework for Python About flare is an app development framework for Python-based web-apps running on top of Pyodide in the browser. It has integrations to concepts with ViUR , an MVC-framework for the Google App Engine platform, but can also be used stand-alone. Fire up the tiny Hello World live demo.","title":"Home"},{"location":"#welcome-to-flare","text":"Web-App development framework for Python","title":"Welcome to flare"},{"location":"#about","text":"flare is an app development framework for Python-based web-apps running on top of Pyodide in the browser. It has integrations to concepts with ViUR , an MVC-framework for the Google App Engine platform, but can also be used stand-alone. Fire up the tiny Hello World live demo.","title":"About"},{"location":"config/","text":"Configuration config.py Coming soon. Serving own Pyodide The script bin/get-pyodide.py downloads a minimal Pyodide with only micropip and setuptools from the Pyodide CDN. Pyodide can also be entirely built and configured on your own, for this check the documentation . Depending on the location where you want to serve your app, some more configuration might be necessary regarding the WASM mimetype. Google App Engine To serve your own Pyodide via Google App Engine, add the following lines to your app.yaml file and modify them when needed, as Google App Engine doesn't recognize WASM files correctly. handlers: - url: /pyodide/(.*\\.wasm)$ static_files: pyodide/\\1 upload: pyodide/.*\\.wasm$ mime_type: application/wasm - url: /pyodide static_dir: pyodide Apache Webserver For apache web-server, this .htaccess configuration helped to serve the app correctly. RewriteEngine off Options -ExecCGI +Indexes IndexOrderDefault Descending Date #Header always set Access-Control-Allow-Origin \"*\" #Header always set Access-Control-Allow-Methods GET <FilesMatch \"\\.py$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .py AddType text/plain .py </FilesMatch> <FilesMatch \"\\.data$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .data AddType application/octet-stream .data </FilesMatch> <FilesMatch \"\\.wasm$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .wasm AddType application/wasm .wasm </FilesMatch>","title":"Configuration"},{"location":"config/#configuration","text":"","title":"Configuration"},{"location":"config/#configpy","text":"Coming soon.","title":"config.py"},{"location":"config/#serving-own-pyodide","text":"The script bin/get-pyodide.py downloads a minimal Pyodide with only micropip and setuptools from the Pyodide CDN. Pyodide can also be entirely built and configured on your own, for this check the documentation . Depending on the location where you want to serve your app, some more configuration might be necessary regarding the WASM mimetype.","title":"Serving own Pyodide"},{"location":"config/#google-app-engine","text":"To serve your own Pyodide via Google App Engine, add the following lines to your app.yaml file and modify them when needed, as Google App Engine doesn't recognize WASM files correctly. handlers: - url: /pyodide/(.*\\.wasm)$ static_files: pyodide/\\1 upload: pyodide/.*\\.wasm$ mime_type: application/wasm - url: /pyodide static_dir: pyodide","title":"Google App Engine"},{"location":"config/#apache-webserver","text":"For apache web-server, this .htaccess configuration helped to serve the app correctly. RewriteEngine off Options -ExecCGI +Indexes IndexOrderDefault Descending Date #Header always set Access-Control-Allow-Origin \"*\" #Header always set Access-Control-Allow-Methods GET <FilesMatch \"\\.py$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .py AddType text/plain .py </FilesMatch> <FilesMatch \"\\.data$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .data AddType application/octet-stream .data </FilesMatch> <FilesMatch \"\\.wasm$\"> Options +Indexes -ExecCGI -Multiviews Order allow,deny Allow from all RemoveHandler .wasm AddType application/wasm .wasm </FilesMatch>","title":"Apache Webserver"},{"location":"html5/","text":"html5 Any flare components are entirely established on top of the html5 -library. The html5 library is flare's core module and key feature, and manages access to the browser's DOM and its items, by implementing a Python object wrapper class for any HTML-element. Such an element is called widget . For example, html5.Div() is the widget representing a div-element, or html5.A() a widget representing an a-element. Widgets can be sub-classed into specialized components, which contain other widgets and components and interact together. The document's body and head can directly be accessed by the static widgets html5.Head() and html5.Body() . All these widgets are inheriting from an abstract widget wrapper called html5.Widget . html5.Widget is the overall superclass which contains most of the functions used when working with DOM elements. Therefore, all widgets are usually handled the same way, except leaf-type widgets, which may not contain any children. First steps When working with native HTML5 widgets, every widget must be created separately and stacked together in the desired order. This is well known from JavaScript's createElement-function. Here's a little code sample. from flare import html5 # Creating a new a-widget a = html5.A() a[\"href\"] = \"https://www.viur.dev\" # assign value to href-attribute a[\"target\"] = \"_blank\" # assign value to target-attribute a.addClass(\"link\") # Add style class \"link\" to element # Append text node \"Hello World\" to the a-element a.appendChild(html5.TextNode(\"Hello World\")) # Append the a-widget to the body-widget html5.Body().appendChild(a) Summarized: html5.Xyz() creates an instance of the desired widget (the notation is that the first letter is always in uppercase-order, the rest is hold in lowercase-order, therefore e.g. html5.Textarea() is used for a textarea) Attributes are accessible via the attribute indexing syntax, like widget[\"attribute\"] . There are some special attributes like style or data that are providing a dict-like access, so widget[\"style\"][\"border\"] = \"1px solid red\" is used. Stacking is performed with widget.appendChild() . There's also widget.prependChild() , widget.insertBefore() and widget.removeChild() for further insertion or removal operations. To access existing child widgets, use widget.children(n) to access the n -th child, or without n to retrieve a list of a children. Parsing widgets from HTML-code Above result can also be achieved much faster, by using the build-in HTML5-parser and renderer . from flare import * html5.Body().appendChild( \"<a href='https://www.viur.dev' target='_blank' class='viur'>Hello World</a>\" ) That's quite simpler, right? This is a very handy feature for prototyping and to quickly integrate new HTML layouts. Widget.appendChild() and other, corresponding functions, allow for an arbitrary number of elements to be added. HTML-code, widgets, text or even lists or tuples of those can be given, like so ul = html5.Ul() ul.appendChild(\"<li class='is-active'>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"and same as I\")) The HTML parser can also do more: When component classes (any class that inherits directly from html5.Widget, like html5.Div or so) are decorated with the html5.tag -decorator, these are automatically made available in the HTML-parser for recognition. Inheritance is normal In most cases, both methods shown above are used together where necessary and useful. Especially when creating new components with a custom behavior inside your app, knowledge of both worlds is required. To create new components, inheriting from existing widgets is usual. If we would like to add our link multiple times within our app, with additional click tracking, we can make it a separate component, like so: import logging from flare import * class Link(html5.A): # inherit Link from html5.A widget def __init__(self, url, *args, target=\"_blank\", **kwargs): super().__init__() self.addClass(\"link\") self[\"href\"] = url self[\"target\"] = \"_blank\" self.appendChild(*args, **kwargs) self.sinkEvent(\"onClick\") def onClick(self, event): logging.info(f\"The link to {self['href']} has been clicked\") html5.Body().appendChild( # Create a link with text Link(\"https://www.viur.dev\", \"ViUR Framework\"), \"<br>\", # Create link with logo Link(\"https://www.python.org\", \"\"\" <img src=\"https://www.python.org/static/community_logos/python-powered-h-50x65.png\" title=\"Python Programming Language\"> \"\"\") ) In this example, we just made our first custom component: The Link -class can be arbitrarily used. Widget basics Following sections describe the most widely used functions of the html5.Widget -class which are inherited by any widget or huger component in flare. Constructor All widgets share the same __init__ -function, having the following signature: def __init__(self, *args, appendTo=None, style=None, **kwargs) *args are any positional arguments that are passed to self.appendChild() . These can be either other widgets or strings containing HTML-code. Non-container widgets like html5.Br() or html5.Hr() don't allow anything passed to this parameter, and throw an Exception. appendTo can be set to another html5.Widget where the constructed widget automatically will be appended to. It substitutes an additional appendChild() -call to insert the constructed Widget to the parent. style allows to specify CSS-classes which are added to the constructed widget using **kwargs specifies any other parameters that are passed to appendChild() , like variables. Insertion and removal These methods manipulate the DOM and it's nodes appendChild() Appends another html5.Widget as child to the parent element: self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") prependChild() Prepends a new child to the parent element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint2 = self.nav.appendChild(\"\"\"<li>Navigation Point 2</li>\"\"\") navpoint2.prependChild((\"\"\"<li>Navigation Point 1</li>\"\"\")) replaceChild() Same as appendChild(), but removes the current children of the Widget first. insertBefore() Inserts a new child element before the target child element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint = self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") navpoint3 = self.nav.appendChild(\"\"\"<li>Navigation Point 3</li>\"\"\") navpoint2 = self.nav.insertBefore(\"\"\"<li>Navigation Point 2</li>\"\"\", navpoint3) If the child element that the new element is supposed to be inserted before does not exist, the new element is appended to the parent instead. removeChild(), removeAllChildren() Either reemoves one child from the parent element or all available children. Visibility and usability Widgets can be switched hidden or disabled. Form elements, for example, might be disabled when a specific condition isn't met. These functions here help to quickly change visibility and usability of widgets, including their child widgets. hide(), show() Hides or shows a widget on demand. To check whether a widget is hidden or not, evaluate widget[\"hidden\"] . In the HTML-parser, this flag can be set using the hidden attribute, e.g. <div hidden>You can't see me.</div> . enable(), disable() Enable or disable the widget in the DOM. Useful for forms and similar UI applications. To check whether a widget is disabled or not, evaluate widget[\"disabled\"] . In the HTML-parser, this flag can be set using the disabled attribute, e.g. <div disabled>I'm disabled</div> . class-attribute modification These methods are helpful for adding CSS-classes quickly. addClass() Adds a class to the html5.Widget and checks to prevent adding the same class multiple times. nav = self.appendChild(\"\"\"<ul></ul>\"\"\") nav.addClass('navlist') Adding a class multiple times might be wanted and is valid. In this case, modify the widget's class -attribute directly by assigning a list to it. removeClass() Checks if the widget has that class and removes it nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") nav.removeClass('big-red-warning-border-color') toggleClass() Toggles a class on or off , depending on whether it has the specified class already or not. hasClass() Checks if the element has a given class or not. Returns True if class name is found and False otherwise. nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") if nav.hasClass('big-red-warning-border-color'): print(\"Help! There is a big red border around this element! Remove the class so we can feel safe again\") HTML parser reference Conditional rendering The attributes flare-if , flare-elif and flare-else can be used on all tags for conditional rendering. This allows for any simple Python expression that evaluates to True or any computed non-boolean value representing True. html5.Body().appendChild(\"\"\" <div>begin</div> <div flare-if=\"i <= 10\">i is just low</div> <div flare-elif=\"i <= 50 and j >=100\">i and j have normal values</div> <div flare-elif=\"i > 50 and j >= 50\">i and j have moderate values</div> <div flare-else>i and j are something different</div> <div>end</div> \"\"\", i=50, j=151) As variables, any kwargs -arguments given to html5.fromHTML() (or related functions) can be involved inside the evaluation. html5.parseHTML() def parseHTML(html: str, debug: bool=False) -> HtmlAst Parses the provided HTML-code according to the tags registered by html5.registerTag() or components that use the html5.tag -decorator. The function returns an abstract syntax tree representation (HtmlAst) of the HTML-code that can be rendered by html5.fromHTML() . html5.fromHTML() def fromHTML(html: [str, HtmlAst], appendTo: Widget=None, bindTo: Widget=None, debug: bool=False, **kwargs) -> [Widget] Renders HTML-code or compiled HTML-code (HtmlAst). appendTo: Defines the Widget where to append the generated widgets to bindTo: Defines the Widget where to bind widgets using the [name] -attribute to debug: Debugging output **kwargs: Any specified kwargs can be used as variables, either for {{replacement}} in attributes or texts or as variables used for conditional rendering . HTML-code can optionally be pre-compiled with html5.parseHTML() , and then executed multiple times (but with differend variables) by fromHTML. This is useful when generating lists of same elements with only replaced variable data. @html5.tag Decorator to register a sub-class of html5.Widget either under its class-name, or an associated tag-name. Examples: from flare import html5 # register class Foo as <foo>-Tag @html5.tag class Foo(html5.Div): pass # register class Bar as <baz>-Tag @html5.tag(\"baz\") class Bar(html5.Div): pass","title":"html5"},{"location":"html5/#html5","text":"Any flare components are entirely established on top of the html5 -library. The html5 library is flare's core module and key feature, and manages access to the browser's DOM and its items, by implementing a Python object wrapper class for any HTML-element. Such an element is called widget . For example, html5.Div() is the widget representing a div-element, or html5.A() a widget representing an a-element. Widgets can be sub-classed into specialized components, which contain other widgets and components and interact together. The document's body and head can directly be accessed by the static widgets html5.Head() and html5.Body() . All these widgets are inheriting from an abstract widget wrapper called html5.Widget . html5.Widget is the overall superclass which contains most of the functions used when working with DOM elements. Therefore, all widgets are usually handled the same way, except leaf-type widgets, which may not contain any children.","title":"html5"},{"location":"html5/#first-steps","text":"When working with native HTML5 widgets, every widget must be created separately and stacked together in the desired order. This is well known from JavaScript's createElement-function. Here's a little code sample. from flare import html5 # Creating a new a-widget a = html5.A() a[\"href\"] = \"https://www.viur.dev\" # assign value to href-attribute a[\"target\"] = \"_blank\" # assign value to target-attribute a.addClass(\"link\") # Add style class \"link\" to element # Append text node \"Hello World\" to the a-element a.appendChild(html5.TextNode(\"Hello World\")) # Append the a-widget to the body-widget html5.Body().appendChild(a) Summarized: html5.Xyz() creates an instance of the desired widget (the notation is that the first letter is always in uppercase-order, the rest is hold in lowercase-order, therefore e.g. html5.Textarea() is used for a textarea) Attributes are accessible via the attribute indexing syntax, like widget[\"attribute\"] . There are some special attributes like style or data that are providing a dict-like access, so widget[\"style\"][\"border\"] = \"1px solid red\" is used. Stacking is performed with widget.appendChild() . There's also widget.prependChild() , widget.insertBefore() and widget.removeChild() for further insertion or removal operations. To access existing child widgets, use widget.children(n) to access the n -th child, or without n to retrieve a list of a children.","title":"First steps"},{"location":"html5/#parsing-widgets-from-html-code","text":"Above result can also be achieved much faster, by using the build-in HTML5-parser and renderer . from flare import * html5.Body().appendChild( \"<a href='https://www.viur.dev' target='_blank' class='viur'>Hello World</a>\" ) That's quite simpler, right? This is a very handy feature for prototyping and to quickly integrate new HTML layouts. Widget.appendChild() and other, corresponding functions, allow for an arbitrary number of elements to be added. HTML-code, widgets, text or even lists or tuples of those can be given, like so ul = html5.Ul() ul.appendChild(\"<li class='is-active'>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"and same as I\")) The HTML parser can also do more: When component classes (any class that inherits directly from html5.Widget, like html5.Div or so) are decorated with the html5.tag -decorator, these are automatically made available in the HTML-parser for recognition.","title":"Parsing widgets from HTML-code"},{"location":"html5/#inheritance-is-normal","text":"In most cases, both methods shown above are used together where necessary and useful. Especially when creating new components with a custom behavior inside your app, knowledge of both worlds is required. To create new components, inheriting from existing widgets is usual. If we would like to add our link multiple times within our app, with additional click tracking, we can make it a separate component, like so: import logging from flare import * class Link(html5.A): # inherit Link from html5.A widget def __init__(self, url, *args, target=\"_blank\", **kwargs): super().__init__() self.addClass(\"link\") self[\"href\"] = url self[\"target\"] = \"_blank\" self.appendChild(*args, **kwargs) self.sinkEvent(\"onClick\") def onClick(self, event): logging.info(f\"The link to {self['href']} has been clicked\") html5.Body().appendChild( # Create a link with text Link(\"https://www.viur.dev\", \"ViUR Framework\"), \"<br>\", # Create link with logo Link(\"https://www.python.org\", \"\"\" <img src=\"https://www.python.org/static/community_logos/python-powered-h-50x65.png\" title=\"Python Programming Language\"> \"\"\") ) In this example, we just made our first custom component: The Link -class can be arbitrarily used.","title":"Inheritance is normal"},{"location":"html5/#widget-basics","text":"Following sections describe the most widely used functions of the html5.Widget -class which are inherited by any widget or huger component in flare.","title":"Widget basics"},{"location":"html5/#constructor","text":"All widgets share the same __init__ -function, having the following signature: def __init__(self, *args, appendTo=None, style=None, **kwargs) *args are any positional arguments that are passed to self.appendChild() . These can be either other widgets or strings containing HTML-code. Non-container widgets like html5.Br() or html5.Hr() don't allow anything passed to this parameter, and throw an Exception. appendTo can be set to another html5.Widget where the constructed widget automatically will be appended to. It substitutes an additional appendChild() -call to insert the constructed Widget to the parent. style allows to specify CSS-classes which are added to the constructed widget using **kwargs specifies any other parameters that are passed to appendChild() , like variables.","title":"Constructor"},{"location":"html5/#insertion-and-removal","text":"These methods manipulate the DOM and it's nodes","title":"Insertion and removal"},{"location":"html5/#appendchild","text":"Appends another html5.Widget as child to the parent element: self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\")","title":"appendChild()"},{"location":"html5/#prependchild","text":"Prepends a new child to the parent element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint2 = self.nav.appendChild(\"\"\"<li>Navigation Point 2</li>\"\"\") navpoint2.prependChild((\"\"\"<li>Navigation Point 1</li>\"\"\"))","title":"prependChild()"},{"location":"html5/#replacechild","text":"Same as appendChild(), but removes the current children of the Widget first.","title":"replaceChild()"},{"location":"html5/#insertbefore","text":"Inserts a new child element before the target child element self.appendChild(\"\"\"<ul class='navlist'></ul>\"\"\") navpoint = self.nav.appendChild(\"\"\"<li>Navigation Point 1</li>\"\"\") navpoint3 = self.nav.appendChild(\"\"\"<li>Navigation Point 3</li>\"\"\") navpoint2 = self.nav.insertBefore(\"\"\"<li>Navigation Point 2</li>\"\"\", navpoint3) If the child element that the new element is supposed to be inserted before does not exist, the new element is appended to the parent instead.","title":"insertBefore()"},{"location":"html5/#removechild-removeallchildren","text":"Either reemoves one child from the parent element or all available children.","title":"removeChild(), removeAllChildren()"},{"location":"html5/#visibility-and-usability","text":"Widgets can be switched hidden or disabled. Form elements, for example, might be disabled when a specific condition isn't met. These functions here help to quickly change visibility and usability of widgets, including their child widgets.","title":"Visibility and usability"},{"location":"html5/#hide-show","text":"Hides or shows a widget on demand. To check whether a widget is hidden or not, evaluate widget[\"hidden\"] . In the HTML-parser, this flag can be set using the hidden attribute, e.g. <div hidden>You can't see me.</div> .","title":"hide(), show()"},{"location":"html5/#enable-disable","text":"Enable or disable the widget in the DOM. Useful for forms and similar UI applications. To check whether a widget is disabled or not, evaluate widget[\"disabled\"] . In the HTML-parser, this flag can be set using the disabled attribute, e.g. <div disabled>I'm disabled</div> .","title":"enable(), disable()"},{"location":"html5/#class-attribute-modification","text":"These methods are helpful for adding CSS-classes quickly.","title":"class-attribute modification"},{"location":"html5/#addclass","text":"Adds a class to the html5.Widget and checks to prevent adding the same class multiple times. nav = self.appendChild(\"\"\"<ul></ul>\"\"\") nav.addClass('navlist') Adding a class multiple times might be wanted and is valid. In this case, modify the widget's class -attribute directly by assigning a list to it.","title":"addClass()"},{"location":"html5/#removeclass","text":"Checks if the widget has that class and removes it nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") nav.removeClass('big-red-warning-border-color')","title":"removeClass()"},{"location":"html5/#toggleclass","text":"Toggles a class on or off , depending on whether it has the specified class already or not.","title":"toggleClass()"},{"location":"html5/#hasclass","text":"Checks if the element has a given class or not. Returns True if class name is found and False otherwise. nav = self.appendChild(\"\"\"<ul class='big-red-warning-border-color'></ul>\"\"\") if nav.hasClass('big-red-warning-border-color'): print(\"Help! There is a big red border around this element! Remove the class so we can feel safe again\")","title":"hasClass()"},{"location":"html5/#html-parser-reference","text":"","title":"HTML parser reference"},{"location":"html5/#conditional-rendering","text":"The attributes flare-if , flare-elif and flare-else can be used on all tags for conditional rendering. This allows for any simple Python expression that evaluates to True or any computed non-boolean value representing True. html5.Body().appendChild(\"\"\" <div>begin</div> <div flare-if=\"i <= 10\">i is just low</div> <div flare-elif=\"i <= 50 and j >=100\">i and j have normal values</div> <div flare-elif=\"i > 50 and j >= 50\">i and j have moderate values</div> <div flare-else>i and j are something different</div> <div>end</div> \"\"\", i=50, j=151) As variables, any kwargs -arguments given to html5.fromHTML() (or related functions) can be involved inside the evaluation.","title":"Conditional rendering"},{"location":"html5/#html5parsehtml","text":"def parseHTML(html: str, debug: bool=False) -> HtmlAst Parses the provided HTML-code according to the tags registered by html5.registerTag() or components that use the html5.tag -decorator. The function returns an abstract syntax tree representation (HtmlAst) of the HTML-code that can be rendered by html5.fromHTML() .","title":"html5.parseHTML()"},{"location":"html5/#html5fromhtml","text":"def fromHTML(html: [str, HtmlAst], appendTo: Widget=None, bindTo: Widget=None, debug: bool=False, **kwargs) -> [Widget] Renders HTML-code or compiled HTML-code (HtmlAst). appendTo: Defines the Widget where to append the generated widgets to bindTo: Defines the Widget where to bind widgets using the [name] -attribute to debug: Debugging output **kwargs: Any specified kwargs can be used as variables, either for {{replacement}} in attributes or texts or as variables used for conditional rendering . HTML-code can optionally be pre-compiled with html5.parseHTML() , and then executed multiple times (but with differend variables) by fromHTML. This is useful when generating lists of same elements with only replaced variable data.","title":"html5.fromHTML()"},{"location":"html5/#html5tag","text":"Decorator to register a sub-class of html5.Widget either under its class-name, or an associated tag-name. Examples: from flare import html5 # register class Foo as <foo>-Tag @html5.tag class Foo(html5.Div): pass # register class Bar as <baz>-Tag @html5.tag(\"baz\") class Bar(html5.Div): pass","title":"@html5.tag"},{"location":"presentation/","text":"html5 A DOM-abstraction layer and API that is used to create client-side Web-Apps running in the browser and written in Python. Overview html5 is used together with Pyodide to implement client-side web-apps with user-interfaces running in any modern browser and written in pure Python. Its highlights are stand-alone with zero dependencies Python class abstraction for any DOM-element, like html5.Div() a built-in HTML parser and executor to generate DOM objects from HTML-code helpers for event-handling, adding/removing CSS-classes, re-arrange elements Pre-defined dialogs and ViUR ignite integration Optimized to work with Pyodide ... but also works with minor changes in other environments (formerly in PyJS, tests had been done with Transcrypt) Basics Every html5.Widget corresponds to a DOM-element html5.Widget() is super-class for all elements HTML-Elements are simply called e.g. html5.Div() , html5.Li() , html5.Input() * Attributes accessable via index widget[\"attribute\"] Helper functions like Widget.hide() , Widget.disable() , Widget.addClass() (*) Always only uppercase first letter, rest is lowercase, therefore html5.Textarea() Inheritance is normal Inherit from basic widgets to implement custom behavior class HelloWorldSayer(html5.Div): def __init__(): super().__init__(\"<h1>Hello World</h1>\") self.addClass(\"i-am-special\") self.sinkEvent(\"onMouseOver\") self.disable() def onMouseOver(self, event): logging.info(\"You're over me!\") html5.Body().appendChild(HelloWorldSayer()) Widget.appendChild() Used to stack elements Accepts other widgets, HTML-Code, compiled HTML-code, atomic values Widget.prependChild() and Widget.insertChild() operate analogously -- ul = html5.Ul() ul.appendChild(\"<li>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"same as I\")) Events Widget.sinkEvent() sinks events to be recognized html5.utils.doesEventHitWidgetOrChildren() Use event.stopPropagate() and event.preventDefault() to delegate event bubbling -- def Clicker(html5.Div): def __init__(): super().__init__(\"Hit me!\") self.sinkEvent(\"onClick\") def onClick(self, event): html5.ext.Alert(\"You clicked me!\") HTML parser & interpreter html5.fromHTML() calls generic HTML parser (returns widget list) Widget.fromHTML() calls Widget-bound HTML parser (returns widget list) html5.parseHTML() parses HTML for faster interpretation (returns HtmlAst) html5.Body.fromHTML(\"\"\"<input [name]=\"input\" class=\"ignt-input\">\"\"\") [name] binds associated name to binder, e.g. html5.Body().input Use appendTo - and bindTo -arguments to change or disable appending and binding target Use **kwargs -arguments to pass in variable value replaced in attributes and plain text # Let's bind something added to the body to our own widget... html5.Body.fromHTML(\"\"\"<input [name]=\"input\" class=\"ignt-input\">\"\"\", bindTo=self) # Let replace some text self.appendChild(\"<h2>{{text}}</h2>\", text=\"Hello World\") -- Widget constructor allows for direct parameters passed to Widget.fromHTML()","title":"html5"},{"location":"presentation/#html5","text":"A DOM-abstraction layer and API that is used to create client-side Web-Apps running in the browser and written in Python.","title":"html5"},{"location":"presentation/#overview","text":"html5 is used together with Pyodide to implement client-side web-apps with user-interfaces running in any modern browser and written in pure Python. Its highlights are stand-alone with zero dependencies Python class abstraction for any DOM-element, like html5.Div() a built-in HTML parser and executor to generate DOM objects from HTML-code helpers for event-handling, adding/removing CSS-classes, re-arrange elements Pre-defined dialogs and ViUR ignite integration Optimized to work with Pyodide ... but also works with minor changes in other environments (formerly in PyJS, tests had been done with Transcrypt)","title":"Overview"},{"location":"presentation/#basics","text":"Every html5.Widget corresponds to a DOM-element html5.Widget() is super-class for all elements HTML-Elements are simply called e.g. html5.Div() , html5.Li() , html5.Input() * Attributes accessable via index widget[\"attribute\"] Helper functions like Widget.hide() , Widget.disable() , Widget.addClass() (*) Always only uppercase first letter, rest is lowercase, therefore html5.Textarea()","title":"Basics"},{"location":"presentation/#inheritance-is-normal","text":"Inherit from basic widgets to implement custom behavior class HelloWorldSayer(html5.Div): def __init__(): super().__init__(\"<h1>Hello World</h1>\") self.addClass(\"i-am-special\") self.sinkEvent(\"onMouseOver\") self.disable() def onMouseOver(self, event): logging.info(\"You're over me!\") html5.Body().appendChild(HelloWorldSayer())","title":"Inheritance is normal"},{"location":"presentation/#widgetappendchild","text":"Used to stack elements Accepts other widgets, HTML-Code, compiled HTML-code, atomic values Widget.prependChild() and Widget.insertChild() operate analogously -- ul = html5.Ul() ul.appendChild(\"<li>lol</li>\") ul.prependChild(html5.Li(1337 * 42)) ul.appendChild(\"<li>me too</li>\", html5.Li(\"same as I\"))","title":"Widget.appendChild()"},{"location":"presentation/#events","text":"Widget.sinkEvent() sinks events to be recognized html5.utils.doesEventHitWidgetOrChildren() Use event.stopPropagate() and event.preventDefault() to delegate event bubbling -- def Clicker(html5.Div): def __init__(): super().__init__(\"Hit me!\") self.sinkEvent(\"onClick\") def onClick(self, event): html5.ext.Alert(\"You clicked me!\")","title":"Events"},{"location":"presentation/#html-parser-interpreter","text":"html5.fromHTML() calls generic HTML parser (returns widget list) Widget.fromHTML() calls Widget-bound HTML parser (returns widget list)","title":"HTML parser &amp; interpreter"},{"location":"presentation/#html5parsehtml-parses-html-for-faster-interpretation-returns-htmlast","text":"html5.Body.fromHTML(\"\"\"<input [name]=\"input\" class=\"ignt-input\">\"\"\") [name] binds associated name to binder, e.g. html5.Body().input Use appendTo - and bindTo -arguments to change or disable appending and binding target","title":"html5.parseHTML() parses HTML for faster interpretation (returns HtmlAst)"},{"location":"presentation/#use-kwargs-arguments-to-pass-in-variable-value-replaced-in-attributes-and-plain-text","text":"# Let's bind something added to the body to our own widget... html5.Body.fromHTML(\"\"\"<input [name]=\"input\" class=\"ignt-input\">\"\"\", bindTo=self) # Let replace some text self.appendChild(\"<h2>{{text}}</h2>\", text=\"Hello World\") -- Widget constructor allows for direct parameters passed to Widget.fromHTML()","title":"Use **kwargs-arguments to pass in variable value replaced in attributes and plain text"},{"location":"setup/","text":"Setup Setting up a new Python web-app with flare is fairly easy. This section describes several things and ways how flare can be used and configured. HTML skeleton Below is a shortened version of the code from hello.html delivered together with the flare repo. Such a skeleton must be individually created for an app written with flare . <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <link rel=\"stylesheet\" href=\"assets/css/style.min.css\"/> <!-- (1) --> <script src=\"https://pyodide-cdn2.iodide.io/v0.16.1/full/pyodide.js\"></script> <!-- <script src=\"pyodide/pyodide.js\"></script> --> <!-- (2) --> <script src=\"assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ prelude: // (3) ` print(\"I'm before any fetch\") ` fetch: { // (4) \"flare\": { \"path\": \"flare\" } }, kickoff: // (5) ` from flare import * html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') flare.popup.Alert(\"Hello World\") ` }); } ); </script> </head> <body class=\"is-loading\"> <!-- (6) --> </body> </html> Notable are the following sections: This is the include for the used Pyodide version. When quickly setting up a project, the default CDN version of Pyodide can be used and is loaded from here. Indeed, it is also possible to serve Pyodide on your own. For this, the utility script bin/get-pyodide.py can be used. This script downloads a minimal version of Pyodide delivered from the CDN and stores it into a folder named pyodide/ . In such a case, the CDN-include here must be removed, and replaced by the local include. get-pyodide.py patches some Pyodide-files to directly run from the URL /pyodide . You can override this setting by specifying a variable window.languagePluginLoader before including the pyodide.js . flare serves a piece of JavaScript code that is necessary to pre-load flare itself and the Python application. For development, it was useful to directly fetch the py-files from the server and store them into a browser-internal filesystem when the Python interpreter from Pyodide can find it. This is done using the module in init.js and the configuration described next. prelude is some Python code that is executed before any modules are fetched. It can be omitted, if not wanted. fetch describes Python source modules that are being fetched before the application starts. This is very useful for development purposes. For every entry (which is the name of the Python package to be created), a further object describing the fetch path and an optional optional attribute is provided. Using the path -attribute, the flare init script looks for a file files.json which provides a listing of the files being fetched. This file is generated using bin/gen-files-json.py which is described below. A Pyodide package can also be pre-compiled from source files, but this is not described in detail here, yet. kickoff is the Python code that is executed when all fetching is done and nothing failed. It is used as the entry point to start the web-app. In the hello.html file, it is just some \"Hello World\" stuff dumped out using flare. The class is-loading is automatically removed when the kickoff code successfully executed. It can be used to show a loading animation or something similar. Writing huger apps When writing huger apps with multiple Python files, the above example doesn't satisfy. For this case, an HTML-file like above still serves as the entry point for the app, but requires a little more configuration. Let's thing about the following minimal setup for a huger app: /flare is the flare repo serving as a library _ /myapp contains our app, which exists only of the files index.html the app entry HTML __init__.py the app source code files.json which is the index file for the flare init script to find its sources We only describe the files in /myapp : index.html <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <script src=\"https://pyodide-cdn2.iodide.io/v0.16.1/full/pyodide.js\"></script> <script src=\"/flare/assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ fetch: { \"flare\": { \"path\": \"/flare/flare\" }, \"myapp\": { \"path\": \".\" } } } ); } ); </script> </head> <body class=\"is-loading\"> </body> </html> init .py : from flare import * if __name__ == \"myapp\": html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') popup.Alert(\"Hello World\") files.json : [ \"__init__.py\" ] The files.json was simply generated using the by ../flare/bin/gen-files-json.py . Whenever a Python file is added, this must be done once. The files.json should also be added to version control, to make the app run out-of-the-box.","title":"Setup"},{"location":"setup/#setup","text":"Setting up a new Python web-app with flare is fairly easy. This section describes several things and ways how flare can be used and configured.","title":"Setup"},{"location":"setup/#html-skeleton","text":"Below is a shortened version of the code from hello.html delivered together with the flare repo. Such a skeleton must be individually created for an app written with flare . <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <link rel=\"stylesheet\" href=\"assets/css/style.min.css\"/> <!-- (1) --> <script src=\"https://pyodide-cdn2.iodide.io/v0.16.1/full/pyodide.js\"></script> <!-- <script src=\"pyodide/pyodide.js\"></script> --> <!-- (2) --> <script src=\"assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ prelude: // (3) ` print(\"I'm before any fetch\") ` fetch: { // (4) \"flare\": { \"path\": \"flare\" } }, kickoff: // (5) ` from flare import * html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') flare.popup.Alert(\"Hello World\") ` }); } ); </script> </head> <body class=\"is-loading\"> <!-- (6) --> </body> </html> Notable are the following sections: This is the include for the used Pyodide version. When quickly setting up a project, the default CDN version of Pyodide can be used and is loaded from here. Indeed, it is also possible to serve Pyodide on your own. For this, the utility script bin/get-pyodide.py can be used. This script downloads a minimal version of Pyodide delivered from the CDN and stores it into a folder named pyodide/ . In such a case, the CDN-include here must be removed, and replaced by the local include. get-pyodide.py patches some Pyodide-files to directly run from the URL /pyodide . You can override this setting by specifying a variable window.languagePluginLoader before including the pyodide.js . flare serves a piece of JavaScript code that is necessary to pre-load flare itself and the Python application. For development, it was useful to directly fetch the py-files from the server and store them into a browser-internal filesystem when the Python interpreter from Pyodide can find it. This is done using the module in init.js and the configuration described next. prelude is some Python code that is executed before any modules are fetched. It can be omitted, if not wanted. fetch describes Python source modules that are being fetched before the application starts. This is very useful for development purposes. For every entry (which is the name of the Python package to be created), a further object describing the fetch path and an optional optional attribute is provided. Using the path -attribute, the flare init script looks for a file files.json which provides a listing of the files being fetched. This file is generated using bin/gen-files-json.py which is described below. A Pyodide package can also be pre-compiled from source files, but this is not described in detail here, yet. kickoff is the Python code that is executed when all fetching is done and nothing failed. It is used as the entry point to start the web-app. In the hello.html file, it is just some \"Hello World\" stuff dumped out using flare. The class is-loading is automatically removed when the kickoff code successfully executed. It can be used to show a loading animation or something similar.","title":"HTML skeleton"},{"location":"setup/#writing-huger-apps","text":"When writing huger apps with multiple Python files, the above example doesn't satisfy. For this case, an HTML-file like above still serves as the entry point for the app, but requires a little more configuration. Let's thing about the following minimal setup for a huger app: /flare is the flare repo serving as a library _ /myapp contains our app, which exists only of the files index.html the app entry HTML __init__.py the app source code files.json which is the index file for the flare init script to find its sources We only describe the files in /myapp : index.html <!doctype html> <html> <head> <meta charset=\"UTF-8\"> <script src=\"https://pyodide-cdn2.iodide.io/v0.16.1/full/pyodide.js\"></script> <script src=\"/flare/assets/js/init.js\"></script> <script> window.addEventListener( \"load\", (event) => { window.init = new init({ fetch: { \"flare\": { \"path\": \"/flare/flare\" }, \"myapp\": { \"path\": \".\" } } } ); } ); </script> </head> <body class=\"is-loading\"> </body> </html> init .py : from flare import * if __name__ == \"myapp\": html5.Body().appendChild('<a href=\"https://www.viur.dev\">Hello World</a>') popup.Alert(\"Hello World\") files.json : [ \"__init__.py\" ] The files.json was simply generated using the by ../flare/bin/gen-files-json.py . Whenever a Python file is added, this must be done once. The files.json should also be added to version control, to make the app run out-of-the-box.","title":"Writing huger apps"}]}